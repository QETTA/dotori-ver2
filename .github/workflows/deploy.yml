# ── Dotori Deploy — Manual Only (workflow_dispatch) ──
# 자동 배포 트리거 없음. 수동 실행만 가능.
# 실행 방법:
#   1. GitHub Actions UI → "Deploy" → "Run workflow"
#   2. CLI: gh workflow run deploy.yml
#   3. 로컬: doctl apps create-deployment 29a6e4f6-b8ae-48b7-9ae3-3e3275b274c2

name: Deploy

on:
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: "Force rebuild (skip SHA cache)"
        required: false
        default: "false"
        type: boolean

permissions:
  contents: read

concurrency:
  group: dotori-deploy
  cancel-in-progress: false

env:
  DO_APP_ID: 29a6e4f6-b8ae-48b7-9ae3-3e3275b274c2

jobs:
  # ── Gate: CI must pass before deploy ──
  ci-gate:
    runs-on: ubuntu-latest
    steps:
      - name: Wait for CI and verify pass
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Waiting for CI on ${GITHUB_SHA::7}..."
          for attempt in $(seq 1 30); do
            RESULT="$(gh run list --repo "${{ github.repository }}" --workflow CI --branch main --limit 10 --json headSha,status,conclusion)"
            STATUS="$(echo "$RESULT" | python3 -c "
          import json,sys
          runs = json.load(sys.stdin)
          target = next((r for r in runs if r.get('headSha','').strip() == '${GITHUB_SHA}'.strip()), None)
          if not target: print('MISSING'); sys.exit(0)
          if target.get('status') != 'completed': print('PENDING'); sys.exit(0)
          print(target.get('conclusion','unknown'))
          ")"
            case "$STATUS" in
              success) echo "CI gate passed (attempt $attempt)"; exit 0 ;;
              PENDING) echo "CI pending... (attempt $attempt/30, wait 10s)"; sleep 10 ;;
              MISSING)
                if [ "$attempt" -ge 30 ]; then
                  echo "::error::No CI run found after 5 minutes"
                  exit 1
                fi
                echo "CI not found yet... (attempt $attempt/30, wait 10s)"; sleep 10 ;;
              *) echo "::error::CI failed ($STATUS)"; exit 1 ;;
            esac
          done
          echo "::error::CI did not complete in 5 minutes"; exit 1

  deploy:
    needs: [ci-gate]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment:
      name: production
      url: ${{ steps.app.outputs.url }}
    steps:
      - uses: actions/checkout@v4

      - name: Enforce DO-only deploy policy
        run: |
          if grep -rn --include='*.yml' 'doctl.*apps.*update' .github/workflows --exclude='deploy.yml'; then
            echo "::error::Forbidden app spec mutation command found"
            exit 1
          fi

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Verify app exists
        run: doctl apps get "${DO_APP_ID}" --format ID --no-header >/dev/null

      - name: Verify live app spec is source mode
        run: |
          SPEC_JSON="$(mktemp)"
          doctl apps spec get "${DO_APP_ID}" --format json > "$SPEC_JSON"
          SPEC_JSON="$SPEC_JSON" python3 - <<'PY'
          import json, os, sys
          spec = json.load(open(os.environ["SPEC_JSON"], "r", encoding="utf-8"))
          svc = next((s for s in (spec.get("services") or []) if s.get("name") == "web"), None)
          if not svc:
              print("ERROR: service 'web' not found", file=sys.stderr); raise SystemExit(1)
          if svc.get("image"):
              print("ERROR: image mode still configured", file=sys.stderr); raise SystemExit(1)
          gh = svc.get("github") or {}
          if gh.get("repo") != "QETTA/dotori-ver2" or gh.get("branch") != "main":
              print("ERROR: source not pinned to QETTA/dotori-ver2@main", file=sys.stderr); raise SystemExit(1)
          print("OK: app spec validated")
          PY
          rm -f "$SPEC_JSON"

      - name: Check if SHA already deployed
        id: active
        run: |
          APP_JSON="$(mktemp)"
          timeout 20s doctl apps get "${DO_APP_ID}" -o json > "$APP_JSON"
          if ! ACTIVE_SHA="$(python3 -c "import json; app=json.load(open('$APP_JSON'))[0]; svcs=(app.get('active_deployment') or {}).get('services') or []; print((svcs[0].get('source_commit_hash') or '').strip() if svcs else '')")"; then
            echo "::warning::python3 failed parsing active deployment — treating as mismatch"
            ACTIVE_SHA=""
          fi
          rm -f "$APP_JSON"
          echo "active_sha=$ACTIVE_SHA" >> "$GITHUB_OUTPUT"
          if [ "$ACTIVE_SHA" = "${GITHUB_SHA}" ] && [ "${{ inputs.force_rebuild }}" != "true" ]; then
            echo "skip_deploy=true" >> "$GITHUB_OUTPUT"
            echo "Skip: SHA already active (${ACTIVE_SHA:0:7})"
          else
            echo "skip_deploy=false" >> "$GITHUB_OUTPUT"
            echo "Deploy: active=${ACTIVE_SHA:0:7} target=${GITHUB_SHA::7}"
          fi

      - name: Trigger DO deployment
        id: deploy
        if: steps.active.outputs.skip_deploy != 'true'
        run: |
          FORCE_FLAG=""
          if [ "${{ inputs.force_rebuild }}" = "true" ]; then
            FORCE_FLAG="--force-rebuild"
          fi
          DEPLOY_ID=""
          for attempt in 1 2 3; do
            echo "attempt ${attempt}/3 at $(date -u +%H:%M:%S)"
            if RAW_ID="$(timeout 45s doctl apps create-deployment "${DO_APP_ID}" $FORCE_FLAG --format ID --no-header 2>/tmp/do-deploy.err)"; then
              DEPLOY_ID="$(echo "$RAW_ID" | tr -d '[:space:]')"
              [ -n "$DEPLOY_ID" ] && break
            fi
            sleep 3
          done
          if [ -z "$DEPLOY_ID" ]; then
            echo "::error::Deployment ID is empty"
            cat /tmp/do-deploy.err 2>/dev/null || true
            exit 1
          fi
          echo "deployment_id=$DEPLOY_ID" >> "$GITHUB_OUTPUT"

      - name: Wait for ACTIVE
        if: steps.active.outputs.skip_deploy != 'true'
        run: |
          DEPLOY_ID="${{ steps.deploy.outputs.deployment_id }}"
          for i in $(seq 1 90); do
            PHASE="$(timeout 20s doctl apps get-deployment "${DO_APP_ID}" "$DEPLOY_ID" --format Phase --no-header 2>/dev/null | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]')" || true
            if [ -z "$PHASE" ]; then
              echo "poll ${i}/90: phase=<empty>"
              sleep 10
              continue
            fi
            echo "poll ${i}/90: phase=$PHASE"
            case "$PHASE" in
              active) echo "Deployment ACTIVE"; exit 0 ;;
              error|canceled|superseded) echo "::error::Terminal phase: $PHASE"; exit 1 ;;
            esac
            sleep 10
          done
          echo "::error::Timeout waiting for deployment"; exit 1

      - name: Resolve production URL
        id: app
        run: |
          URL="$(timeout 20s doctl apps get "${DO_APP_ID}" --format DefaultIngress --no-header | tr -d '[:space:]')"
          echo "url=$URL" >> "$GITHUB_OUTPUT"

      - name: Health check
        env:
          CRON_SECRET: ${{ secrets.CRON_SECRET }}
        run: |
          BASE="${{ steps.app.outputs.url }}"
          BASE="${BASE%/}"
          if [ -z "$BASE" ]; then
            echo "::error::Production URL is empty — cannot run health check"
            exit 1
          fi
          # Liveness check (required)
          for i in $(seq 1 60); do
            if curl -fsS --max-time 5 "$BASE/api/health" >/dev/null 2>&1; then
              echo "Liveness OK in $((i*2))s"
              break
            fi
            sleep 2
          done
          if ! curl -fsS --max-time 5 "$BASE/api/health" >/dev/null 2>&1; then
            echo "::error::Liveness check failed after 120s"
            exit 1
          fi
          # Deep health check (optional — warn only)
          if [ -n "${CRON_SECRET:-}" ]; then
            if curl -fsS --max-time 8 \
              -H "Authorization: Bearer ${CRON_SECRET}" \
              "$BASE/api/health/deep" >/dev/null 2>&1; then
              echo "Deep health OK"
            else
              echo "::warning::Deep health check failed (CRON_SECRET mismatch or DB issue). Liveness passed — deploy continues."
            fi
          else
            echo "Deep health auth secret unavailable, skipping."
          fi
          echo "Health check passed"

      - name: Verify deployed commit
        run: |
          APP_JSON="$(mktemp)"
          timeout 20s doctl apps get "${DO_APP_ID}" -o json > "$APP_JSON"
          python3 -c "
          import json, os, sys
          app = json.load(open('$APP_JSON'))[0]
          svcs = (app.get('active_deployment') or {}).get('services') or []
          sha = (svcs[0].get('source_commit_hash') or '').strip() if svcs else ''
          expected = '${GITHUB_SHA}'.strip()
          if sha != expected:
              print(f'ERROR: mismatch expected={expected[:7]} actual={sha[:7]}', file=sys.stderr)
              sys.exit(1)
          print(f'OK: verified ({sha[:7]})')
          "
          rm -f "$APP_JSON"

      - name: Summary
        if: always()
        run: |
          BASE="${{ steps.app.outputs.url }}"
          BASE="${BASE%/}"
          {
            echo "## Deploy"
            echo "| Key | Value |"
            echo "|-----|-------|"
            echo "| URL | ${BASE} |"
            echo "| Commit | \`${GITHUB_SHA::7}\` |"
            echo "| Deploy ID | \`${{ steps.deploy.outputs.deployment_id || 'already-active' }}\` |"
            echo "| Force | ${{ inputs.force_rebuild }} |"
          } >> "$GITHUB_STEP_SUMMARY"
