# R26 — 백엔드·프론트 안정성 패치 (4 에이전트)
> 설계일: 2026-02-24
> 근거: Chat/Community/Engine 계층 전체 검수 결과
> 선행 검수: apiFetch localhost 폴백 (✅안전), response envelope (✅일관), rate-limit (✅방어됨)

---

## 검수 요약 — 확인된 실제 버그

| # | 심각도 | 버그 | 파일 | 라인 |
|---|--------|------|------|------|
| 1 | **P0** | 채팅 스트림 AbortController 없음 → 이탈 시 메모리 누수 | useChatStream.ts | L102 |
| 2 | **P0** | 채팅 메시지 ID `Date.now()` 충돌 → 빠른 전송 시 메시지 소실 | useChatStream.ts | L82,93 |
| 3 | **P0** | 좋아요 에러 시 낙관적 업데이트 미롤백 → UI 불일치 | community/page.tsx | L213-251 |
| 4 | **P1** | 액션 버튼 "compare" 하드코딩 폴백 → UX 흐름 깨짐 | blocks.ts L294, recommendation.ts L41 |
| 5 | **P1** | 채팅 스트림 unmount 가드 없음 → React state 경고 | useChatStream.ts | L118+ |
| 6 | **P2** | 커뮤니티 fetchPosts unmount 가드 없음 | community/page.tsx | L157-206 |
| 7 | **P2** | 액션 핸들러 미매핑 action → raw 문자열 전송 (예측 불가) | chat/page.tsx | L424 |

### 안전 확인 (수정 불필요)
- ✅ apiFetch 서버 baseUrl: `throw Error`로 방어 (localhost 폴백 없음)
- ✅ response envelope: `/api/chat` + `/api/chat/history` 모두 `{ data: {} }` 일관
- ✅ SSE 스트림: 별도 포맷 (올바름)
- ✅ quick_replies: snake_case 일관 + 방어적 파싱 (history L6-21)
- ✅ rate-limit: 서버 429 + 클라이언트 감지 + 메시지 표시

---

## SHARED_RULES (모든 에이전트 공통)

```
1. 수정 대상 파일만 수정. SCOPE 밖 파일 절대 금지.
2. 기존 API 계약(response envelope, field naming) 변경 금지.
3. 기존 테스트 깨뜨리지 않기. 새 테스트 추가 권장.
4. 산출물: git diff + 요약 7줄 + 테스트 커맨드.
5. 빌드 검증: env -u NODE_ENV npm run build (0 errors)
6. 테스트: npm test (기존 111 pass + 신규 추가분)
7. framer-motion 사용 금지 → motion/react만.
8. Catalyst 컴포넌트(src/components/catalyst/) 내부 수정 금지.
9. 타입 안전성: any 사용 금지, unknown + 타입 가드 사용.
10. 에러 UI 규칙: 모든 에러는 사용자 메시지 + 복구 액션(재시도/뒤로가기) 제공.
```

---

## Agent 1: 채팅 스트림 안정성 (P0 × 3건)

```
[CONTEXT]
useChatStream.ts의 fetch()에 AbortController가 없어 페이지 이탈 시 스트림이 계속 읽힘.
메시지 ID가 Date.now() 기반이라 빠른 전송(1ms 이내) 시 충돌.
스트림 읽기 루프에 unmount 가드가 없어 React state 업데이트 경고 발생.

[GOAL]
채팅 스트림의 3가지 안정성 버그를 수정하여 메모리 누수, 메시지 소실, state 경고 제거.

[NON-GOALS]
- 스트림 API 응답 포맷 변경 없음
- 채팅 UI 레이아웃 변경 없음
- 재시도 자동화 (P2, 이번 스코프 아님)

[AC]
1. fetch()에 AbortController.signal 추가, 컴포넌트 unmount 시 abort 호출
2. 메시지 ID를 `${role}-${Date.now()}-${Math.random().toString(36).slice(2,7)}` 형식으로 교체하여 충돌 방지
3. 스트림 읽기 루프에서 abort 시 graceful exit (AbortError catch)
4. setMessages/setIsLoading 호출 전 aborted 여부 체크
5. 기존 에러 핸들링(quota_exceeded, 429) 로직 그대로 유지
6. 빌드 0 errors, 테스트 111+ pass

[SCOPE FILES]
1. src/components/dotori/chat/useChatStream.ts — 메인 수정 대상

[DETAILED CHANGES]

### useChatStream.ts

#### 1-A. AbortController 추가 (L49 부근, 기존 state 선언 뒤에)
```typescript
// 기존:
const [isLoading, setIsLoading] = useState(false);
const lastPromptRef = useRef("");

// 추가:
const abortControllerRef = useRef<AbortController | null>(null);
```

#### 1-B. sendMessage 내 fetch에 signal 연결 (L102)
```typescript
// 기존:
const response = await fetch("/api/chat/stream", {
  method: "POST",
  headers: { ... },
  body: JSON.stringify({ ... }),
});

// 변경:
abortControllerRef.current?.abort();
const controller = new AbortController();
abortControllerRef.current = controller;

const response = await fetch("/api/chat/stream", {
  method: "POST",
  headers: { ... },
  body: JSON.stringify({ ... }),
  signal: controller.signal,
});
```

#### 1-C. 메시지 ID 충돌 방지 (L82, L93)
```typescript
// 기존:
id: `user-${Date.now()}`,
// ...
id: `assistant-${Date.now()}`,

// 변경:
id: `user-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`,
// ...
id: `assistant-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`,
```

#### 1-D. 스트림 읽기 루프에 abort 가드 추가
스트림 while 루프 안에서:
```typescript
// 루프 시작 부분에 추가:
if (controller.signal.aborted) break;
```

sendMessage의 catch 블록에 AbortError 처리 추가:
```typescript
} catch (error) {
  if (error instanceof DOMException && error.name === "AbortError") {
    // 정상적인 abort — 무시
    return;
  }
  // 기존 에러 핸들링 유지
}
```

#### 1-E. cleanup 반환 (useChatStream 훅에서)
sendMessage와 함께 cleanup 함수도 반환하거나,
useEffect cleanup에서 abort 호출하도록 chat/page.tsx와 연동:
```typescript
// useChatStream 내부에 cleanup 추가:
const cleanup = useCallback(() => {
  abortControllerRef.current?.abort();
}, []);

return { isLoading, sendMessage, retryLastMessage, cleanup };
```

chat/page.tsx에서 useEffect cleanup으로 호출:
```typescript
useEffect(() => {
  return () => cleanup();
}, [cleanup]);
```

[TEST PLAN]
env -u NODE_ENV npm run build && npm test
# 수동 검증: 채팅 중 페이지 이탈 → 콘솔에 state 경고 없음
# 수동 검증: 빠르게 2회 전송 → 두 메시지 모두 정상 표시
```

---

## Agent 2: 커뮤니티 상태 관리 수정 (P0 + P2)

```
[CONTEXT]
1. toggleLike에서 API 에러 시 낙관적 업데이트를 롤백하지 않아 UI 불일치.
2. fetchPosts에 unmount 가드 없어 페이지 이탈 후 state 업데이트 경고.

[GOAL]
커뮤니티 페이지의 좋아요 롤백 + fetch unmount 안전성 확보.

[NON-GOALS]
- GPS 인증 플로우 변경 (finally 블록에서 isVerifying 리셋 존재, 동작함)
- 커뮤니티 레이아웃 변경 없음
- API 엔드포인트 변경 없음

[AC]
1. toggleLike catch 블록에서 낙관적 업데이트 롤백 (setLikedPosts/setPosts 원복)
2. fetchPosts를 AbortController 또는 isMounted 가드로 보호
3. 기존 IntersectionObserver 무한스크롤 로직 유지
4. 빌드 0 errors, 테스트 111+ pass

[SCOPE FILES]
1. src/app/(app)/community/page.tsx — L213-251 (toggleLike), L157-206 (fetchPosts)

[DETAILED CHANGES]

### community/page.tsx — toggleLike 롤백 (L213-251)

```typescript
// 현재 코드 (L240-241):
} catch {
  fetchPosts(1)
}

// 변경: 낙관적 업데이트 롤백 후 refetch
} catch {
  // 롤백: 에러 전 상태로 복원
  if (isLiked) {
    // DELETE가 실패 → liked 상태 복원
    setLikedPosts((prev) => new Set(prev).add(postId))
    setPosts((prev) =>
      prev.map((p) => (p.id === postId ? { ...p, likes: p.likes + 1 } : p)),
    )
  } else {
    // POST가 실패 → liked 해제
    setLikedPosts((prev) => {
      const next = new Set(prev)
      next.delete(postId)
      return next
    })
    setPosts((prev) =>
      prev.map((p) => (p.id === postId ? { ...p, likes: Math.max(0, p.likes - 1) } : p)),
    )
  }
}
```

### community/page.tsx — fetchPosts unmount 가드

fetchPosts 호출하는 useEffect에 isMounted 패턴 적용:
```typescript
// 첫 로드 useEffect (L206-211 부근):
useEffect(() => {
  let isMounted = true
  const load = async () => {
    await fetchPosts(1)
    // fetchPosts 내부에서 isMounted 체크가 어려우므로,
    // 대안: fetchPosts를 AbortController 기반으로 리팩토링
  }
  load()
  return () => { isMounted = false }
}, [fetchPosts])
```

또는 fetchPosts 내부에 early return 가드를 추가하는 방식도 가능.
(구체적 구현은 에이전트 재량, AC만 충족하면 됨)

[TEST PLAN]
env -u NODE_ENV npm run build && npm test
# 수동 검증: 좋아요 클릭 → 네트워크 끊김 → 좋아요 상태 원복 확인
# 수동 검증: 커뮤니티 진입 → 빠른 뒤로가기 → 콘솔 경고 없음
```

---

## Agent 3: 엔진 액션 버튼 수정 (P1)

```
[CONTEXT]
response-builder에서 액션 버튼의 action 필드가 의미와 무관하게 "compare"로 하드코딩.
- blocks.ts L294: "시설 탐색하기" 버튼 → action: "compare" (잘못됨, "explore"여야 함)
- recommendation.ts L41: "전체 검색" 버튼 → action: "compare" (잘못됨, "broaden"이어야 함)
클라이언트(chat/page.tsx)의 quickActionMap에는 "explore"→/explore 라우트,
"broaden"→"다른 시설을 더 찾아줘" 메시지가 이미 매핑되어 있음 (L397-388).
즉 action 값만 올바르게 바꾸면 클라이언트가 정확히 동작함.

[GOAL]
엔진 응답 블록의 action 값을 클라이언트 quickActionMap/actionRoutes와 정확히 일치시킴.

[NON-GOALS]
- 클라이언트 quickActionMap 변경 없음 (이미 올바름)
- 새 액션 타입 추가 없음
- 응답 메시지 텍스트 변경 없음

[AC]
1. blocks.ts L294: action "compare" → "explore" (id와 일치시킴)
2. recommendation.ts L41: action "compare" → "broaden" (id와 일치시킴)
3. 클라이언트 actionRoutes에 "explore"→"/explore" 이미 존재 (L398) — 변경 불필요 확인
4. 클라이언트 quickActionMap에 "broaden"→"다른 시설을 더 찾아줘" 이미 존재 (L387) — 변경 불필요 확인
5. 기존 엔진 테스트 통과
6. 빌드 0 errors, 테스트 111+ pass

[SCOPE FILES]
1. src/lib/engine/response-builder/blocks.ts — L294
2. src/lib/engine/response-builder/recommendation.ts — L41

[REPLACEMENTS — 정확한 old→new]

### blocks.ts L288-296
```typescript
// 기존:
{
  id: "explore",
  label: "시설 탐색하기",
  action: "compare",       // ← 잘못됨
  variant: "outline",
},

// 변경:
{
  id: "explore",
  label: "시설 탐색하기",
  action: "explore",       // ← id와 일치, 클라이언트 actionRoutes["explore"]→"/explore"
  variant: "outline",
},
```

### recommendation.ts L37-43
```typescript
// 기존:
{
  id: "broaden",
  label: "전체 검색",
  action: "compare",       // ← 잘못됨
  variant: "outline",
},

// 변경:
{
  id: "broaden",
  label: "전체 검색",
  action: "broaden",       // ← id와 일치, 클라이언트 quickActionMap["broaden"]→"다른 시설을 더 찾아줘"
  variant: "outline",
},
```

[TEST PLAN]
env -u NODE_ENV npm run build && npm test
npm run test:engine
# 검증: blocks.ts, recommendation.ts에서 action !== id인 경우 0건
grep -n '"action":.*"compare"' src/lib/engine/response-builder/*.ts
# → blocks.ts의 정당한 compare 버튼(L198)만 남아야 함
```

---

## Agent 4: 클라이언트 액션 핸들러 방어 + 테스트 (P2)

```
[CONTEXT]
chat/page.tsx L424에서 미매핑 actionId가 들어오면 raw 문자열을 그대로 sendMessage로 전송.
이는 예측 불가능한 UX를 만듦 (예: action="unknown_type" → 토리챗에 "unknown_type" 전송).
또한 엔진 액션 타입에 대한 테스트가 부재.

[GOAL]
미매핑 액션에 대한 방어 로직 추가 + 엔진 블록 액션 정합성 테스트 작성.

[NON-GOALS]
- 새 액션 타입 추가 없음
- UI 레이아웃 변경 없음
- 기존 quickActionMap/actionRoutes 수정 최소화

[AC]
1. handleBlockAction에서 미매핑 actionId에 console.warn 추가 + fallback을 사용자 메시지 대신 무시(또는 toast 알림)로 변경
2. 엔진 블록 테스트: 모든 응답 블록의 action이 클라이언트에서 처리 가능한 값인지 검증하는 테스트 1개 추가
3. 빌드 0 errors, 테스트 pass

[SCOPE FILES]
1. src/app/(app)/chat/page.tsx — L419-424 (handleBlockAction fallback)
2. src/__tests__/engine-action-consistency.test.ts — 신규 생성

[DETAILED CHANGES]

### chat/page.tsx L419-424

```typescript
// 기존:
if (quickActionMap[actionId]) {
  sendMessage(quickActionMap[actionId])
  return
}
sendMessage(actionId)  // ← raw fallback

// 변경:
if (quickActionMap[actionId]) {
  sendMessage(quickActionMap[actionId])
  return
}

// 미매핑 액션: 경고 로그 + 무시 (예측 불가 메시지 전송 방지)
if (process.env.NODE_ENV === 'development') {
  console.warn(`[chat] Unmapped action: "${actionId}"`)
}
```

### src/__tests__/engine-action-consistency.test.ts — 신규

```typescript
import { describe, it, expect } from 'vitest'

// 클라이언트에서 처리 가능한 action 값 목록 (chat/page.tsx 기준)
const KNOWN_ACTION_ROUTES = ['explore', 'waitlist', 'interests', 'community', 'settings', 'login', 'import']
const KNOWN_QUICK_ACTIONS = ['recommend', 'compare', 'strategy', 'generate_report', 'generate_checklist', 'checklist', 'broaden']
const KNOWN_SPECIAL = ['retry']

const ALL_KNOWN_ACTIONS = new Set([
  ...KNOWN_ACTION_ROUTES,
  ...KNOWN_QUICK_ACTIONS,
  ...KNOWN_SPECIAL,
])

describe('Engine action button consistency', () => {
  it('all action values in blocks.ts should be known to client', async () => {
    const blocksModule = await import('@/lib/engine/response-builder/blocks')
    // blocks.ts의 exported 함수들을 호출하여 반환되는 blocks 내 action 값 검증
    // 구체적 구현은 에이전트가 blocks.ts export 구조에 맞춰 작성
  })

  it('known actions list matches chat page quickActionMap + actionRoutes', () => {
    // quickActionMap과 actionRoutes의 키가 ALL_KNOWN_ACTIONS에 포함되는지 확인
    expect(ALL_KNOWN_ACTIONS.size).toBeGreaterThan(0)
  })
})
```
(테스트 구체 구현은 에이전트가 import 구조에 맞춰 작성. AC: 테스트 파일 존재 + pass)

[TEST PLAN]
env -u NODE_ENV npm run build && npm test
npx vitest run src/__tests__/engine-action-consistency.test.ts
```

---

## 빌드 검증 (wave 완료 후)

```bash
cd /home/sihu2/dotori-ver2-qetta/dotori-app

# 1. 빌드 + 전체 테스트
env -u NODE_ENV npm run build && npm test

# 2. 엔진 테스트 단독
npm run test:engine

# 3. action "compare" 하드코딩 잔류 검사
grep -n 'action:.*"compare"' src/lib/engine/response-builder/*.ts
# → blocks.ts L198 (정당한 compare 버튼)만 남아야 함

# 4. Date.now() ID 패턴 잔류 검사
grep -n 'id:.*Date.now()' src/components/dotori/chat/useChatStream.ts
# → 0 matches

# 5. AbortController 적용 확인
grep -n 'AbortController\|signal.*abort' src/components/dotori/chat/useChatStream.ts
# → 2+ matches
```

---

## 에이전트 파일 소유권

| Agent | 파일 | 유형 |
|-------|------|------|
| 1 | useChatStream.ts, chat/page.tsx (cleanup useEffect만) | 프론트 상태 |
| 2 | community/page.tsx | 프론트 상태 |
| 3 | blocks.ts, recommendation.ts | 엔진 백엔드 |
| 4 | chat/page.tsx (handleBlockAction만), engine-action-consistency.test.ts (신규) | 프론트+테스트 |

**충돌 주의**: Agent 1과 Agent 4가 chat/page.tsx 공유.
→ Agent 1은 useEffect cleanup 추가만, Agent 4는 handleBlockAction 수정만.
→ 수정 영역이 100줄 이상 떨어져 있어 **병렬 실행 가능** (git merge 자동 해결).

---

## 실행 권장

```bash
# Wave 1: Agent 1 + Agent 2 + Agent 3 (병렬, 파일 충돌 없음)
# Wave 2: Agent 4 (Agent 3 완료 후, action 값 변경 반영 확인)

# codex-wave.sh 사용 시:
./scripts/codex-wave.sh /tmp/r26-tasks.txt --wave=3
# Wave 1: Agent 1,2,3 → tsc 검증 → Wave 2: Agent 4
```

---

## 부록: 검수에서 안전 확인된 항목 (수정 불필요)

| 항목 | 근거 |
|------|------|
| apiFetch localhost 폴백 | `throw Error` 방어 (api.ts L85) |
| response envelope `{ data }` | chat, history, stream 모두 일관 |
| quick_replies snake_case | 서버/클라이언트/타입 모두 snake_case |
| rate-limit 429 감지 | 서버 Retry-After 헤더 + 클라이언트 감지 + UI 메시지 |
| suppressHydrationWarning | formatRelativeTime 사용처 10곳 전부 적용됨 |
| "use client" 누락 | 0건 (모든 훅 사용 컴포넌트에 존재) |
| AbortController (기존) | useFacilities.ts에 올바르게 적용됨 (참고 패턴) |
